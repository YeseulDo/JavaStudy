# JAVA ONLINE STUDY _ STUDYHALLE #3  
__과제 : 연산자__  
__목표 : 자바가 제공하는 다양한 연산자를 학습하기.__

---

## 연산자란?  


    int a = 4 * 5 ;

연산자 operator : 연산을 수행하는 기호.    `= , *`  
피연산자 operand : 연산자가 연산을 수행하기 위해 필요한 연산의 대상.   `4 , 5`  
식 expression : 연산자와 피연산자를 조합하여 계산하고자 하는 바를 표현한 것.    `4 * 5`  


- 대부분의 연산자는 두 개의 피연산자를 필요로 하며, 하나 또는 세 개의 피연산자를 필요로 하는 연산자도 있다.  
- 연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다.  
  이 결과값을 대입연산자 "=" 를 사용해 변수와 같은 값을 저장할 수 있는 공간에 저장하여 프로그램에 사용한다.  
<br>


## 산술 연산자  

### ▶ 사칙연산자 + - * /  


일반적인 사칙연산을 수행하는 연산자이다.  
피연산자가 정수형인 경우, 나누는 수로 0을 사용할 수 없다. 사용 시 런타임에러가 발행한다. (ArithmeticException)  
연산결과의 타입은 피연산자의 타입과 일치한다. 나눗셈시 주의가 필요하며, 반올림은 발생하지 않는다.

    int a = 10;  
    int b = 4;  
    int c = a/b;  // int c = 2  

올바른 연산결과를 얻기 위해서는 a, b 중 하나 혹은 양쪽 모두를 실수형으로 형변환하여 계산하여야 한다.  


사칙연산의 피연산자는 숫자뿐만 아니라 문자도 가능하다.  
문자는 해당 문자의 유니코드로 바뀌어 저장되므로, 문자간의 사칙연산은 정수간의 연산과 동일하다.  
```
char c1 = 'a';
char c2 = (char)(c1 + 1);   // c2 = 'b';
char c3 = 'a' + 1;          // c3 = 'b';
```
- c2의 경우 연산 시 c1이 int로 변환되어 덧셈연산을 수행하므로, 다시 char에 담기 위해서는 형변환이 필요하다.  
  명시적으로 캐스팅해주지 않을 경우 컴파일 에러가 발생한다.  
- c3의 경우, 'a' + 1 는 리터럴간의 연산이기 때문에 명시적으로 형변환을 해주지 않아도 에러가 발생하지 않는다.  
  리터럴간의 연산은 실행과정동안 변하는 값이 아니기 때문에, 컴파일 시 컴파일러가 미리 계산해서 그 결과로 대체함으로써 코드를 보다 효율적으로 만든다.  


### ▶ 나머지연산자 %  
왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자.  
나눗셈과 마찬가지로 나누는 수(오른쪽 피연산자)에 0을 사용할 수 없다.  
나누는 수로 음수도 허용하지만, 부호가 무시되므로 결과는 절대값으로 나눈 나머지와 결과가 같다.  
나머지 연산자는 주로 짝수, 홀수, 배수 검사등에 사용된다.  
<br>


__※ 산술변환 (usual arithmetic conversion)__  
이항연산자의 연산 시, 피연산자의 타입이 일치해야 연산이 가능하므로 연산 전에 타입을 일치시킬 필요가 있다.  
작은타입에서 큰 타입으로 형 변환시 자동적으로 형변환되므로 형변환연산자를 생략할 수 있는데,  
__이처럼 연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것__ 을 산술변환이라고 한다.  

- 두 피연산자의 타입 중 더 큰 타입으로 일치시킨다. <sup>작은타입으로 형변환 시 원래의 값이 손실될 가능성이 있다</sup>  
```
int a = 10;  
float b = 4.0f;  
float c = a/b;  // float c = 2.5f; : a는 float으로 자동형변환되어 연산된다.
```
- 피연산자의 타입이 int보다 작은 타입일 시 int로 변환된다. <sup>int가 가장 효율적인 처리가 가능한 타입이다</sup>  

```
byte a = 10;  
byte b = 30;  
byte c = a + b; // 에러발생 : a,b는 int로 자동형변환되어 연산된다.
```
<br>


## 비트 연산자  

### ▶ 비트 연산자 & | ^ ~ << >>  

피연산자를 비트단위로 논리 연산하는 연산자.  
피연산자를 이진수로 표현했을 때 각 자리에 대해 연산을 수행하며, 피연산자로는 정수(문자포함)만 허용된다.  

- __| (OR)__   
    피연산자 중 한 쪽의 값이 1이면 1을 결과로 얻고, 그 외에는 0을 얻는다.  
    주로 특정 비트의 값을 변경할 때 사용한다.  
- __& (AND)__  
    피연산자 양 쪽이 모두 1이어야 1을 결과로 얻고, 그 외에는 0을 얻는다.  
    주로 특정 비트의 값을 뽑아낼 때 사용한다.  
- __^ (XOR)__  
    피연산자의 값이 서로 다를 때만 1을 결과로 얻고, 같을 때는 0을 얻는다. (배타적 OR)  
    같은 값으로 두고 XOR연산을 수행 시 원래의 값으로 돌아오는 특징을 살려 간단한 암호화에 사용되기도 한다.  

- __~ (NOT)__  
    비트 전환 연산자. 피연산자를 이진수로 표현했을 때, 0은 1로 1은 0으로 바꾼다.  
    비트가 전환 되고 나면, 부호있는 타입의 피연산자는 부호가 반대로 변경된다. (= 1의 보수)  
    그래서 이 연산자를 1의 보수 연산자라고도 한다.  

시프트연산자 << 는 덧셈연산자보다 우선순위가 낮다  
비트연산자 & 은 비교연산자 == 보다 우선순위가 낮다  

## 관계 연산자, 비교 연산자  


두 피연산자를 비교하는 데 사용되는 연산자이다. 주로 조건문과 반복문의 조건식에 사용되며, 연산결과는 true, false 중 하나이다.  
비교 연산자 역시 이항 연산자이므로 비교하는 피연산자의 타입이 다를 경우, 범위가 큰 쪽으로 자동 형변환되어 비교한다.  


### ▶ 대소비교 연산자 < > <= >=  


두 피연산자의 값의 크기를 비교하는 연산자.  
참이면 true, 거짓이면 false를 반환.  
boolean형을 제외한 나머지 기본형에 사용할 수 있고, 참조형에는 사용할 수 없다.  


### ▶ 등가비교 연산자 == !=  

두 피연산자의 값이 같은지 다른지를 비교하는 연산자.  
기본형은 물론 참조형, 즉 모든 자료형에 사용할 수 있다. 그러나 기본형과 참조형 간의 비교는 불가능하다.
- 기본형 : 변수에 저장되어 있는 값이 같은 지 비교  
- 참조형 : 객체의 주소값을 저장하므로 두 개의 피연산자(참조변수)가 같은 객체를 가리키고 있는 지 비교  

__문자열의 비교__  
문자열의 비교에는 비교연산자가 아닌 equals() 메서드를 사용한다. 
```
String str1 = "abc";  
String str2 = new String("abc");  
str1 == str2; // false  
str1.equals(str2); // true  
```
비교연산자는 str1과 str2가 같은 객체인지를 비교하고, equals()는 문자열의 내용이 같은 지 비교한다.

## 논리 연산자  


두 개 이상의 조건이 결합된 경우, AND나 OR로 연결하여 하나의 식으로 표현할 수 있게 해 주는 연산자.  


### ▶ 논리 연산자 && || !  

- && (AND)  피연산자 양쪽 모두 true 일 때 true를 결과로 얻는다.  
            어느 한 쪽만 false이어도 전체 연산결과가 false이므로, 좌측 피연산자가 false이면 우측 피연산자의 값은 평가하지 않는다.  
            → 연산결과가 false 일 확률이 높은 피연산자를 연산자의 왼쪽에 놓는 것이 효율적이다.  
- || (OR)   피연산자 어느 한 쪽이 true일 때 true를 결과로 얻는다.  
            어느 한 쪽만 true이어도 전체 결과가 true이므로, 좌측 피연산자가 true이면 우측 피연산자의 값은 평가하지 않는다.  
            → 연산결과가 true 일 확률이 높은 피연산자를 연산자의 왼쪽에 놓는 것이 효율적이다.  
- ! (NOT)   피연산자가 true이면 false를, false이면 true를 반환한다.

논리연산자는 피연산자로 boolean 또는 boolean형 값을 결과로 하는 조건식 만을 허용한다.   

__`i는 10보다 큰 2의 배수이지만 6의 배수는 아니다.`__  
```
(i%2==0 && i>10) || i%6!=0
```
__`문자 ch는 영대문자 또는 소문자이다.`__  
```
('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')  
```


## instanceof p.362  
## assignment(=) operator  

    int y = 3;  
    
대입연산자는 우변의 값을 좌변에 저장하고, 저장된 값을 연산결과로 반환한다. 이 식에서의 연산결과는 3.


## 화살표(->) 연산자  
## 3항 연산자  

### 단항연산자  
#### ▶ 증감연산자 ++ --  
피연산자에 저장된 값을 1 증가 또는 감소시킨다.  
대부분의 연산자는 값을 읽어서 연산에 사용할 뿐, 피연산자의 타입이나 값을 변경시키지 않는다.  
오직 대입연산자와 증감연산자만 피연산자의 값을 변경한다.  

전위형 (prefix) : 피연산자의 왼쪽에 위치하며, 값이 참조되기 전에 증가시킨다. __`j = ++i;`__  

    ++i;
    j = i;  

후위형 (postfix) : 피연산자의 오른쪽에 위치하며, 값이 참조된 후 증가시킨다. __`j = i++;`__  

    j = i;
    i++;

수식이나 메서드호출에 포함되지 않고 독립적인 하나의 문장으로 쓰인 경우에는 전위형과 후위형의 결과에 차이가 없다.


#### ▶ 부호연산자 + -  
부호연산자 + 는 특별한 기능이 없으며 사용되는 경우도 거의 없다.  
부호연산자 - 는 피연산자의 부호를 반대로 변경한 결과를 반환한다.  
boolean, char을 제외한 기본형에만 사용할 수 있다.  
덧셈연산자 + , 뺄셈연산자 - 과는 다른 연산자이다.  


## 연산자 우선 순위 

식에 사용된 연산자가 둘 이상인 경우, 연산자의 우선순위에 의해서 연산순서가 결정된다.  
우선순위가 확실하지 않을 시 먼저 계산되어야 하는 부분을 괄호로 묶어주는 것이 좋다.  

    x > 4 / 2 + 5 && y > -2 + 5

- 단항연산자 > 이항연산자 > 삼항연산자  
- 산술연산자 (*, /) > 산술연산자 (+, -) > 비교연산자 > 논리연산자(&, &&) > 논리연산자(|, ||) > 대입연산자  
<br>

__연산자의 결합규칙__  
같은 우선순위의 연산자들이 여러 개 있는 경우에 연산을 처리하는 규칙.  
단항연산자와 대입연산자를 제외한 모든 연산은 왼쪽에서 오른쪽의 순서로 연산을 수행한다.  


<br>

## (optional) Java 13. switch 연산자  



