# JAVA ONLINE STUDY _ STUDYHALLE #3  
__과제 : 연산자__  
__목표 : 자바가 제공하는 다양한 연산자를 학습하기.__

---

## 연산자란?  


    int a = 4 * 5 ;

연산자 operator : 연산을 수행하는 기호.    `= , *`  
피연산자 operand : 연산자가 연산을 수행하기 위해 필요한 연산의 대상.   `4 , 5`  
식 expression : 연산자와 피연산자를 조합하여 계산하고자 하는 바를 표현한 것.    `4 * 5`  


- 대부분의 연산자는 두 개의 피연산자를 필요로 하며, 하나 또는 세 개의 피연산자를 필요로 하는 연산자도 있다.  
- 연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다.  
  이 결과값을 대입연산자 "=" 를 사용해 변수와 같은 값을 저장할 수 있는 공간에 저장하여 프로그램에 사용한다.  
<br>


## 산술 연산자  

### ▶ 사칙연산자 + - * /  


일반적인 사칙연산을 수행하는 연산자이다.  
피연산자가 정수형인 경우, 나누는 수로 0을 사용할 수 없다. 사용 시 런타임에러가 발행한다. (ArithmeticException)  
연산결과의 타입은 피연산자의 타입과 일치한다. 나눗셈시 주의가 필요하며, 반올림은 발생하지 않는다.

    int a = 10;  
    int b = 4;  
    int c = a/b;  // int c = 2  

올바른 연산결과를 얻기 위해서는 a, b 중 하나 혹은 양쪽 모두를 실수형으로 형변환하여 계산하여야 한다.  


사칙연산의 피연산자는 숫자뿐만 아니라 문자도 가능하다.  
문자는 해당 문자의 유니코드로 바뀌어 저장되므로, 문자간의 사칙연산은 정수간의 연산과 동일하다.  
```
char c1 = 'a';
char c2 = (char)(c1 + 1);   // c2 = 'b';
char c3 = 'a' + 1;          // c3 = 'b';
```
- c2의 경우 연산 시 c1이 int로 변환되어 덧셈연산을 수행하므로, 다시 char에 담기 위해서는 형변환이 필요하다.  
  명시적으로 캐스팅해주지 않을 경우 컴파일 에러가 발생한다.  
- c3의 경우, 'a' + 1 는 리터럴간의 연산이기 때문에 명시적으로 형변환을 해주지 않아도 에러가 발생하지 않는다.  
  리터럴간의 연산은 실행과정동안 변하는 값이 아니기 때문에, 컴파일 시 컴파일러가 미리 계산해서 그 결과로 대체함으로써 코드를 보다 효율적으로 만든다.  
<br>


### ▶ 나머지연산자 %  
왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자.  
나눗셈과 마찬가지로 나누는 수(오른쪽 피연산자)에 0을 사용할 수 없다.  
나누는 수로 음수도 허용하지만, 부호가 무시되므로 결과는 절대값으로 나눈 나머지와 결과가 같다.  
나머지 연산자는 주로 짝수, 홀수, 배수 검사등에 사용된다.  
<br>


__※ 산술변환 (usual arithmetic conversion)__  
이항연산자의 연산 시, 피연산자의 타입이 일치해야 연산이 가능하므로 연산 전에 타입을 일치시킬 필요가 있다.  
작은타입에서 큰 타입으로 형 변환시 자동적으로 형변환되므로 형변환연산자를 생략할 수 있는데,  
__이처럼 연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것__ 을 산술변환이라고 한다.  

- 두 피연산자의 타입 중 더 큰 타입으로 일치시킨다. <sup>작은타입으로 형변환 시 원래의 값이 손실될 가능성이 있다</sup>  
```
int a = 10;  
float b = 4.0f;  
float c = a/b;  // float c = 2.5f; : a는 float으로 자동형변환되어 연산된다.
```
- 피연산자의 타입이 int보다 작은 타입일 시 int로 변환된다. <sup>int가 가장 효율적인 처리가 가능한 타입이다</sup>  

```
byte a = 10;  
byte b = 30;  
byte c = a + b; // 에러발생 : a,b는 int로 자동형변환되어 연산된다.
```
<br>


## 비트 연산자  

### ▶ 비트 연산자 & | ^ ~ << >>  

피연산자를 비트단위로 논리 연산하는 연산자.  
피연산자를 이진수로 표현했을 때 각 자리에 대해 연산을 수행하며, 피연산자로는 정수(문자포함)만 허용된다.  

- __| (OR)__   
    피연산자 중 한 쪽의 값이 1이면 1을 결과로 얻고, 그 외에는 0을 얻는다.  
    주로 특정 비트의 값을 변경할 때 사용한다. 
    
- __& (AND)__  
    피연산자 양 쪽이 모두 1이어야 1을 결과로 얻고, 그 외에는 0을 얻는다.  
    주로 특정 비트의 값을 뽑아낼 때 사용한다.   
    ※ 비트연산자 & 은 비교연산자 == 보다 우선순위가 낮다. 
    
- __^ (XOR)__  
    피연산자의 값이 서로 다를 때만 1을 결과로 얻고, 같을 때는 0을 얻는다. (배타적 OR)  
    같은 값으로 두고 XOR연산을 수행 시 원래의 값으로 돌아오는 특징을 살려 간단한 암호화에 사용되기도 한다.  
    
- __～ (NOT)__  
    비트 전환 연산자. 피연산자를 이진수로 표현했을 때, 0은 1로 1은 0으로 바꾼다.  
    비트가 전환 되고 나면, 부호있는 타입의 피연산자는 부호가 반대로 변경된다. (= 1의 보수)  
    그래서 이 연산자를 1의 보수 연산자라고도 한다.  


### ▶ 시프트 연산자  <<  >>  >>>

- 피연산자의 각 자리를 왼쪽이나 오른쪽으로 이동(shift)한다고 해서 시프트연산자라고 한다.

- __`<<`__ 연산자의 경우 부호에 상관없이 왼쪽으로 이동시키며 빈칸에 0을 채운다. 
- __`>>`__ 연산자의 경우 오른쪽으로 이동하기 때문에, 왼쪽 피연산자의 부호를 유지하기 위해  
    음수인 경우 빈자리를 1, 양수인 경우 0으로 채운다.  
- __`>>>`__ 연산자의 경우, 자바에만 존재하는 연산으로 기본원리는 __`>>`__ 와 같다.  
    하지만 부호와 관계없이 0으로 빈자리를 채우기 때문에 결과값은 언제나 양수이다.
    
    
- `8 << 2` 는 왼쪽 피연산자인 10진수 8의 2진수를 왼쪽으로 2자리 이동한다는 의미이다.  
    이 때, 자리이동으로 저장범위를 벗어난 값들은 버려지고, 빈자리는 0으로 채워진다.  

| 8 << 2                                                  | 연산과정                                                                 |
|---------------------------------------------------------|------------------------------------------------------------------|
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \| 0 \| 0 \| 0 \| 0 \| 1 \| 0 \| 0 \| 0 \|     | 10진수 8은 2진수로 __00001000__                           |
| __0 &nbsp; 0__ \| 0 \| 0 \| 1 \| 0 \| 0 \| 0 \| &nbsp;&nbsp; \| &nbsp;&nbsp; \|           | 2진수로 나타낸 8을 왼쪽으로 2자리 이동시킨다.              |
| ~~0 &nbsp; 0~~ \| 0 \| 0 \| 1 \| 0 \| 0 \| 0 \| __0__ \| __0__ \|                         | 저장범위를 벗어난 값은 버려지고, 빈자리는 0으로 채운다.   |
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \| 0 \| 0 \| 1 \| 0 \| 0 \| 0 \| 0 \| 0 \|     | '8 << 2'의 결과는 00100000 == 10진수 32                   |
<br>

    
- 시프트연산자의 좌측 피연산자는 산술변환이 적용되어 int보다 작은타입은 int로 자동변환된다.  
    우측 피 연산자는 산술변환이 적용되지 않는다.  

- 2진수를 왼쪽으로 n자리 이동하면 피연산자를 2<sup>n</sup>으로 곱한 결과를 얻을 수 있다. __x << n 은 x * 2<sup>n</sup>__  
- 2진수를 오른쪽으로  n자리 이동하면 피연산자를 2<sup>n</sup>으로 나눈 결과를 얻을 수 있다. __x >> n 은 x / 2<sup>n</sup>__      
    
- 시프트연산자는 일반 나눗셈, 곱셈 연산자보다 빠른 속도를 요하는 곳에 사용한다.  

- 시프트연산자 << 는 덧셈연산자보다 우선순위가 낮다.  
<br>


## 관계 연산자, 비교 연산자  


두 피연산자를 비교하는 데 사용되는 연산자이다. 주로 조건문과 반복문의 조건식에 사용되며, 연산결과는 true, false 중 하나이다.  
비교 연산자 역시 이항 연산자이므로 비교하는 피연산자의 타입이 다를 경우, 범위가 큰 쪽으로 자동 형변환되어 비교한다.  


### ▶ 대소비교 연산자 < > <= >=  


두 피연산자의 값의 크기를 비교하는 연산자.  
참이면 true, 거짓이면 false를 반환.  
boolean형을 제외한 나머지 기본형에 사용할 수 있고, 참조형에는 사용할 수 없다.  


### ▶ 등가비교 연산자 == !=  

두 피연산자의 값이 같은지 다른지를 비교하는 연산자.  
기본형은 물론 참조형, 즉 모든 자료형에 사용할 수 있다. 그러나 기본형과 참조형 간의 비교는 불가능하다.
- 기본형 : 변수에 저장되어 있는 값이 같은 지 비교  
- 참조형 : 객체의 주소값을 저장하므로 두 개의 피연산자(참조변수)가 같은 객체를 가리키고 있는 지 비교  

__문자열의 비교__  
문자열의 비교에는 비교연산자가 아닌 equals() 메서드를 사용한다. 
```
String str1 = "abc";  
String str2 = new String("abc");  
str1 == str2; // false  
str1.equals(str2); // true  
```
비교연산자는 str1과 str2가 같은 객체인지를 비교하고, equals()는 문자열의 내용이 같은 지 비교한다.  
<br>


## 논리 연산자  


두 개 이상의 조건이 결합된 경우, AND나 OR로 연결하여 하나의 식으로 표현할 수 있게 해 주는 연산자.  


### ▶ 논리 연산자 && || !  

- && (AND)  피연산자 양쪽 모두 true 일 때 true를 결과로 얻는다.  
            어느 한 쪽만 false이어도 전체 연산결과가 false이므로, 좌측 피연산자가 false이면 우측 피연산자의 값은 평가하지 않는다.  
            → 연산결과가 false 일 확률이 높은 피연산자를 연산자의 왼쪽에 놓는 것이 효율적이다.  
- || (OR)   피연산자 어느 한 쪽이 true일 때 true를 결과로 얻는다.  
            어느 한 쪽만 true이어도 전체 결과가 true이므로, 좌측 피연산자가 true이면 우측 피연산자의 값은 평가하지 않는다.  
            → 연산결과가 true 일 확률이 높은 피연산자를 연산자의 왼쪽에 놓는 것이 효율적이다.  
- ! (NOT)   피연산자가 true이면 false를, false이면 true를 반환한다.

논리연산자는 피연산자로 boolean 또는 boolean형 값을 결과로 하는 조건식 만을 허용한다.   

__`i는 10보다 큰 2의 배수이지만 6의 배수는 아니다.`__  
```
( i % 2 == 0 && i > 10 ) || i % 6 != 0
```
__`문자 ch는 영대문자 또는 소문자이다.`__  
```
('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')  
```
<br>


## instanceof   

참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용되는 연산자이다.  
주로 조건문에 사용되며, 왼쪽에는 참조변수를, 오른쪽에는 타입(클래스명) 이 피연산자로 위치한다.  
연산의 결과로 true, false 중 하나를 반환한다.  

instanceof를 이용한 연산결과로 true를 얻었다는 것은, 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 의미한다.  
실제 인스턴스와 같은 타입의 연산 이외에, 조상타입과의 연산에도 true를 결과로 얻는다.  

값이 null인 참조변수에 대해 instanceof연산을 수행 시 false를 결과로 얻는다.

<img src="3_1.JPG"> 
<br>


## assignment operator 대입 연산자, 할당 연산자  
대입 연산자 __`=`__ 는 변수와 같은 저장공간에 값, 수식의 연산결과를 저장하는데 사용된다.
오른쪽 피연산자의 값을 왼쪽 피연산자에 저장하고, 저장된 값을 연산결과로 반환한다.

    System.out.println(int y = 3);  
    
3을 y에 저장하고, 연산결과인 3을 화면에 출력한다.  
대입연산자는 연산자들 중 가장 낮은 우선순위를 가지며, 진행방향은 오른쪽에서 왼쪽이다.  
왼쪽 피연산자는 반드시 변수처럼 값을 변경할 수 있는 것이어야 하며, 리터럴이나 상수같이 값을 저장할 수 없는 것들은 사용할 수 없다.  

### 복합대입연산자 op=  
대입연산자는 다른연산자와 결합하여 사용할 수 있다.  
결합된 두 연산자는 반드시 공백없이 붙여써야 한다.  

|   op=   |      =     |
|:-------:|:----------:|
|  i += 3 |  i = i + 3 |
|  i %= 3 |  i = i % 3 |
| i <<= 3 | i = i << 3 |
|  i ^= 3 |  i = i ^ 3 |
|   ...   |     ...    |  
<br>


## 화살표(->) 연산자  

__람다식 Lambda expression__  
메서드를 하나의 식으로 표현한 것으로 함수를 간략하면서도 명확한 식으로 표현할 수 있게 해 준다.  
람다식의 도입으로 인해 자바는 객체지향언어임 동시에 함수형언어의 기능까지 갖추게 되었다.

```
(매개변수 선언) -> { 문장들 : 함수/메서드의 내용부분 }  
(int a, int b) -> { return a > b ? a : b; }  
```
 
메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 익명함수(anonymous function)라고도 한다.  
람다식은 메서드의 매개변수로 전달되어지는 것이 가능하고, 메서드의 결과로 반환될 수도 있다.  
 
 
```
 (a, b) -> a > b ? a : b
```

- 반환값이 있는 메서드의 경우 return문 대신 식으로 대신할 수 있다. 식의 연산결과가 반환값이 된다.  
- 람다식에 선언된 매개변수의 타입은 추론이 가능한 경우 생략가능한데, 대부분의 경우에 생략이 가능하다.  
    반환타입이 없는 이유도 항상 추론이 가능하기 때문이다. 
- 선언된 매개변수가 하나인 경우에는 괄호()를 생략가능하다. 매개변수의 타입이 선언된 경우는 생략불가능하다.  
- 괄호 {} 안의 문장이 하나일 때는 {} 를 생략가능하다. 그러나 return문의 경우는 생략불가능하다.  
    또한 {}를 생략하는 경우 문장의 끝에 ; 를 붙이지 않아야 한다.
<br>


## 3항 연산자  

### 단항연산자  
#### ▶ 증감연산자 ++ --  
피연산자에 저장된 값을 1 증가 또는 감소시킨다.  
대부분의 연산자는 값을 읽어서 연산에 사용할 뿐, 피연산자의 타입이나 값을 변경시키지 않는다.  
오직 대입연산자와 증감연산자만 피연산자의 값을 변경한다.  

전위형 (prefix) : 피연산자의 왼쪽에 위치하며, 값이 참조되기 전에 증가시킨다. __`j = ++i;`__  

    ++i;
    j = i;  

후위형 (postfix) : 피연산자의 오른쪽에 위치하며, 값이 참조된 후 증가시킨다. __`j = i++;`__  

    j = i;
    i++;

수식이나 메서드호출에 포함되지 않고 독립적인 하나의 문장으로 쓰인 경우에는 전위형과 후위형의 결과에 차이가 없다.


#### ▶ 부호연산자 + -  
부호연산자 + 는 특별한 기능이 없으며 사용되는 경우도 거의 없다.  
부호연산자 - 는 피연산자의 부호를 반대로 변경한 결과를 반환한다.  
boolean, char을 제외한 기본형에만 사용할 수 있다.  
덧셈연산자 + , 뺄셈연산자 - 과는 다른 연산자이다.  


### 삼항연산자  
#### ▶ 조건연산자 ? :   
조건연산자는 조건식, 식1, 식2 모두 세 개의 피연산자를 필요로 하는 삼항연산자이며,  
삼항연산자는 조건연산자 하나 뿐이다.  
```
조건식 ? 식1 : 식2  
```
첫 번째 피연산자인 조건식의 평가 결과가 true이면 식1이, false이면 식2가 연산결과가 된다.  
```
result = (x > y) ? x : y;  
```  
x > y가 true이면 result에 x의 값이 저장되고, false이면 y의 값이 저장된다.  
식1고 식2의 타입이 다른 경우, 산술변환이 발생한다.  
<br>


## 연산자 우선 순위 

식에 사용된 연산자가 둘 이상인 경우, 연산자의 우선순위에 의해서 연산순서가 결정된다.  
우선순위가 확실하지 않을 시 먼저 계산되어야 하는 부분을 괄호로 묶어주는 것이 좋다.  

    x > 4 / 2 + 5 && y > -2 + 5

- 단항연산자 > 이항연산자 > 삼항연산자  
- 산술연산자 (*, /) > 산술연산자 (+, -) > 비교연산자 > 논리연산자(&, &&) > 논리연산자(|, ||) > 대입연산자  
<br>

__연산자의 결합규칙__  
같은 우선순위의 연산자들이 여러 개 있는 경우에 연산을 처리하는 규칙.  
단항연산자와 대입연산자를 제외한 모든 연산은 왼쪽에서 오른쪽의 순서로 연산을 수행한다.  
<br>


## (optional) Java 13. switch 연산자  

REF : https://docs.oracle.com/en/java/javase/13/language/switch-expressions.html  
읽고 이해한대로 정리했기 때문에 잘못 이해한 부분이 있을수도 있습니다..?  

- __Switch Expressions__  
    기존의 switch문과는 다르게, 단어 그대로 하나의 식 expression 으로써 연산결과를 반환한다.   
    반환값이 존재하기 때문에 문장 statement 내에서 사용하거나, 변수에 저장하는 것이 가능하다.   

- __arrow case__  
    break문의 부재로 인한 fall-through를 방지할 수 있는 형태의 구문.  
    <sup>※ fall-through : switch-case문에서 break를 걸지 않았을 경우, 다음 case문이 실행되는 것.</sup>  
    ```
    case label_1, label_2, ..., label_n -> expression;|throw-statement;|block  
    ```
    화살표 오른쪽에 위치하는 값이나 식의 결과가 switch expression의 결과값이 된다.  
    기존의 switch-case 구문에서도 colon case 대신 arrow case를 사용할 수 있다.  
    

- __yield statement__  
    switch expression 에서 break문을 대체해서 사용하는 구문.  
    _It takes one argument, which is the value that the case label produces in a switch expression._  
    하나의 인자를 가지는데, case label이 switch expression에서 만드는 결과 값...  
    뭐래 대충 switch expression의 반환값을 이야기 하는것같음.  


switch문과 switch식(?)의 가장 큰 차이는 반환값인 듯 하다.  
arrow case뿐만 아니라 colon case 역시 양 쪽에서 다 사용가능하지만,  
yield문에 의해 반환되는 값이 존재하는지의 유무에 따라 switch문과 switch식이 구분가능하다는 말 인듯..?  
